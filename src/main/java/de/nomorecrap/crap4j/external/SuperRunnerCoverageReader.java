package de.nomorecrap.crap4j.external;

import com.agitar.coverage.ClassCoverage;
import de.nomorecrap.crap4j.CrapProject;
import de.nomorecrap.crap4j.MethodCoverage;
import de.nomorecrap.crap4j.util.FileUtil;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This class will read the acov files generated by the super runner task in the
 * ant file triggered by the TestRunner.
 * 
 * @author bobevans
 * 
 */
public class SuperRunnerCoverageReader {

  private CrapProject project;

  public SuperRunnerCoverageReader(CrapProject p) {
    this.project = p;
  }

  public List<MethodCoverage> read() throws IOException {
    List<MethodCoverage> list = new ArrayList<MethodCoverage>();
    List<File> covFiles = null;
    try {
      covFiles = FileUtil.getAllFilesInDirMatchingPattern(project.getCoverageDir(), ".*.acov", false);
      
    } catch (Exception e1) {
      e1.printStackTrace(System.err);
      return list;
    }
    if (covFiles == null || covFiles.size() < 1) {
      System.err.println("Cannot find coverage results files in "
          + project.getCoverageDir());
      return list;
    } else {
      // withoutTestFiles.remove(0);
      for (File covFile : covFiles) {
        try {
          list.addAll(readFile(covFile));
        } catch (IOException e) {
//          if (Main.getInstance(getCrap4jHome(), getAgitatorEclipseApiPlugin(crap4jHome), getAgitatorEclipseCoveragePluginDir(crap4jHome), getJunitLib(agitatorEclipseApiPlugin), getAntHome(agitatorEclipseApiPlugin)).debug)
            System.err.println("Could not read coverage file: "
                + covFile.getAbsolutePath());
            //throw new RuntimeException(e);
        }
      }
      return list;
    }
  }

  public List<MethodCoverage> readFile(File f) throws IOException {
    DataInputStream in = null;
    try {
      in = new DataInputStream(new BufferedInputStream(new FileInputStream(f)));
      return read(in);
    } finally {
      in.close();
    }
  }

  public List<MethodCoverage> Xread(DataInput in) throws IOException {
    List<MethodCoverage> methodCoverages = new ArrayList<MethodCoverage>();
    int fileVersion = in.readInt();
    @SuppressWarnings("unused")
    boolean washerMode = (fileVersion < 4) || in.readBoolean();// THROW
    // AWAY
    String className = in.readUTF();

    /* String sourceFile = */in.readUTF();// THROW AWAY
    /* long originalChecksum = */in.readLong(); // THROW AWAY
    /* String instrClassName = */in.readUTF(); // THROW AWAY
    @SuppressWarnings("unused")
    long originalTimeStamp = (fileVersion >= 1) ? in.readLong() : 0; // THROW
    // AWAY

    List<String> methodNames = readMethods(in, className);
    Map<Integer, List<MyCoveragePoint>> covPoints = readCoveragePoints(in);
    return createMethodCoverages(methodCoverages, methodNames, covPoints);
  }

  public List<MethodCoverage> read(DataInput in) throws IOException {
    List<MethodCoverage> methodCoverages = new ArrayList<MethodCoverage>();
    ClassCoverage cc = new ClassCoverage("unknown", new File(project.getCoverageDir()));
    cc.read(in);
    String[] methodNames = cc.getMethodNames();
    for (String methodName : methodNames) {      
      int[] totalMethodCoverage = cc.getTotalMethodCoverage(methodName);
      float percentCovered = (float)totalMethodCoverage[1] / (float)totalMethodCoverage[0];
      methodCoverages.add(new MethodCoverage(makeFullyQualifiedMethodName(cc.getClassName(), methodName), percentCovered));
    }
    
    return methodCoverages;
  }


  protected List<MethodCoverage> createMethodCoverages(
      List<MethodCoverage> methodCoverages, List<String> methodNames,
      Map<Integer, List<MyCoveragePoint>> covPoints) {
    for (int i = 0; i < methodNames.size(); i++) {
      String methodName = methodNames.get(i);
      int totalPointsForMethod = 0;
      int coveredPointsForMethod = 0;
      List<MyCoveragePoint> listOfPoints = covPoints.get(i);
      if (listOfPoints == null) {
        listOfPoints = new ArrayList<MyCoveragePoint>();
      }
      for (MyCoveragePoint point : listOfPoints) {
        if (point.getType() == MyCoveragePoint.T_UNKNOWN)
          continue;
        else {
          totalPointsForMethod++;
          if (point.getTimesReached() > 0) {
            coveredPointsForMethod++;
          }
        }
      }
      float percentCovered = ((float) coveredPointsForMethod) / (float) totalPointsForMethod;
      methodCoverages.add(new MethodCoverage(methodName, percentCovered));

    }
    return methodCoverages;
  }

  private Map<Integer, List<MyCoveragePoint>> readCoveragePoints(DataInput in)
      throws IOException {
    int pointCount = in.readInt();
    Map<Integer, List<MyCoveragePoint>> covPoints = new HashMap<Integer, List<MyCoveragePoint>>();
    for (int i = 0; i < pointCount; ++i) {
      MyCoveragePoint point = new MyCoveragePoint(in);
      if (point.getType() != MyCoveragePoint.T_UNKNOWN) {
        List<MyCoveragePoint> pointsForMethod = covPoints.get(point
            .getMethodNumber());
        if (pointsForMethod == null) {
          pointsForMethod = new ArrayList<MyCoveragePoint>();
        }
        pointsForMethod.add(point);
        covPoints.put(point.getMethodNumber(), pointsForMethod);
      }
    }
    return covPoints;
  }

  private List<String> readMethods(DataInput in, String className)
      throws IOException {
    int methodCount = in.readInt();
    List<String> methodNames = new ArrayList<String>();
    for (int i = 0; i < methodCount; ++i) {
      String methodName = in.readUTF();
      methodNames.add(makeFullyQualifiedMethodName(className, methodName));
      in.readBoolean(); // ignore methodPrivates thing
    }
    return methodNames;
  }

  private String makeFullyQualifiedMethodName(String className, String methodName) {
    return className.replace(File.separatorChar, '.') + "."
        + methodName.replaceAll("\\.", "");
  }

}

/**
 * Represents a single coverage data point.
 * 
 * @author scott
 */
class MyCoveragePoint {

  public MyCoveragePoint() {
  }

  /**
   * Standard constructor, initializes fields that are henceforth read-only.
   * 
   * @param type
   *          coverage point type ID
   * @param byteOffset
   *          byte offset from method start
   * @param methodNumber
   *          method index within the class
   * @param lineNumber
   *          approximate line number if known or -1 if not
   */
  public MyCoveragePoint(int type, int byteOffset, int methodNumber,
      int lineNumber) {
    this.type = type;
    this.byteOffset = byteOffset;
    this.methodNumber = methodNumber;
    this.lineNumber = lineNumber;
  }

  /**
   * One-step construct-and-read.
   * 
   * @param in
   *          input stream
   * @throws java.io.IOException
   *           error during read
   */
  public MyCoveragePoint(DataInput in) throws IOException {
    read(in);
  }

  /**
   * The type of this coverage point, as enumerated by the T_* constants
   * enumerated in this class.
   * 
   * @return coverage point type ID
   */
  public int getType() {
    return type;
  }

  /**
   * This is the byte offset of the corresponding code in the <em>original</em>
   * class file.
   * 
   * @return byte offset from method start
   */
  public int getByteOffset() {
    return byteOffset;
  }

  /**
   * This number can be passed to {@link ClassCoverage#getMethodName(int)} to
   * turn it into a String. (Code outside of methods will always end up assigned
   * to either a constructor or class initializer.)
   * 
   * @return method index within the class
   */
  public int getMethodNumber() {
    return methodNumber;
  }

  /**
   * The closest line number corresponding to this point, or -1 if unknown.
   * 
   * @return line number or -1
   */
  public int getLineNumber() {
    return lineNumber;
  }

  void setType(int type) {
    this.type = type;
  }

  void setByteOffset(int byteOffset) {
    this.byteOffset = byteOffset;
  }

  void setMethodNumber(int methodNumber) {
    this.methodNumber = methodNumber;
  }

  void setLineNumber(int lineNumber) {
    this.lineNumber = lineNumber;
  }

  /**
   * The number of times this point has been reached. Stops increasing at
   * {@link Integer#MAX_VALUE}.
   * 
   * @return number of times reached
   */
  public int getTimesReached() {
    return timesReached;
  }

  public boolean setTimesReached(int timesReached) {
    if (this.timesReached != timesReached) {
      this.timesReached = timesReached;
      return true;
    } else {
      return false;
    }
  }

  public void read(DataInput in) throws IOException {
    type = in.readInt();
    byteOffset = in.readInt();
    methodNumber = in.readInt();
    lineNumber = in.readInt();
    timesReached = in.readInt();
  }

  public String toString() {
    return "[" + lineNumber + "/" + timesReached + "/" + type + "]";
  }

  public static final int T_UNKNOWN = -1;

  public static final int T_LINE = 0;

  public static final int T_IF_FALSE = 1;

  public static final int T_IF_TRUE = 2;

  private int type = T_UNKNOWN;

  private int byteOffset;

  private int methodNumber;

  private int lineNumber;

  private int timesReached;

}
